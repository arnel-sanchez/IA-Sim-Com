\documentclass[12pt, letterpaper,spanish]{article}
\usepackage[letterpaper]{geometry}
\usepackage[T1]{fontenc} %para escribir con caracteres utf8 como tildes
\usepackage[utf8]{inputenc} %para escribir con caracteres utf8 como tildes
\usepackage[spanish]{babel} %para escribir con caracteres utf8 como tildes
\usepackage{lmodern} % latin modern font
\usepackage{color}
\usepackage[svgnames]{xcolor} % para hacer enfasis con colores
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{array}
\usepackage{mathtools} % para el modulo
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\DeclarePairedDelimiter\norm{\lVert}{\rVert}%
\hypersetup{
	colorlinks=true,
	linkcolor=black,
	filecolor=magenta,      
	urlcolor=cyan,
}

\usepackage{listings}
\lstloadlanguages{Python}
\definecolor{background}{rgb}{0.52, 0.52, 0.51}
\definecolor{keywords}{rgb}{1.0, 0.0, 0.5}
\definecolor{comments}{rgb}{0.75, 0.75, 0.75}
\definecolor{strings}{rgb}{0.91, 0.84, 0.42}
\definecolor{names}{rgb}{0.4, 1.0, 0.0}
\definecolor{white}{rgb}{1.0, 1.0, 1.0}
\definecolor{types}{rgb}{0.13, 0.67, 0.8}
\definecolor{numbers}{rgb}{0.54, 0.17, 0.89}

\lstdefinelanguage{PySharp}{
	keywords={method, include, if, else, elif, while, continue, break, return},
	keywordstyle=\color{keywords}\bfseries,
	ndkeywords={int, void, rider, true, false},
	ndkeywordstyle=\color{types}\bfseries,
	identifierstyle=\color{white},
	sensitive=false,
	emph={print, test, example, Rossi, curves},
	emphstyle=\color{names},
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{comments}\ttfamily,
	stringstyle=\color{strings}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=PySharp,
	backgroundcolor=\color{background},
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}


\usepackage{amsthm} % para teoremas y lemas
\usepackage{graphicx} % para imagenes
\usepackage{titling} % para el pretitle
\usepackage{clrscode3e} % para pseudocodigos
\usepackage[stable]{footmisc} % para permitir footnotes in los encabezados

%\usepackage[cache=false]{minted} %para representar los codigos necesita config extra
%\renewcommand\theFancyVerbLine{\normalsize\arabic{FancyVerbLine}} % incrementar el tamaño de linenumbers de minted


\newtheorem{theorem}{Teorema}[subsection]
\newtheorem{corollary}{Corolario}[theorem]
\newtheorem{lemma}{Lema}[subsection]
\newtheorem{lemmacorollary}{Corolario}[lemma]
\theoremstyle{definition}
\newtheorem*{definition}{Definición}
\theoremstyle{remark}
\newtheorem*{remark}{Observación}
\renewcommand{\qedsymbol}{$\blacksquare$} % se remplaza el simbolo vacio de final de demostración
\graphicspath{ {./_static/} }

%--------------------------
% NO MODIFICAR ESTE DOCUMENTO
%--------------------------
	
\begin{document}
	
\begin{titlepage}
	\begin{center}
		\includegraphics[width = 3cm]{escudoUH} 
	\end{center}
	\begin{center}
		Universidad de La Habana \\\vspace{0.2cm} Facultad de Matemática y Computación
	\end{center}
	\centering
	\vspace{1cm} \par
	{\scshape\Large Proyecto de Compilación + Intenteligencia Artificial + Simulación\par}
	\vspace{5mm} \par
	{\scshape\Huge Simulador de un Jefe Técnico de MotoGP\par}
	\vspace{5mm} \par
	\vfill
	{\Large \textbf{Autores:} \par}
	{\large Arnel Sánchez Rodríguez \space Grupo: C312 \par}
	\href{mailto:arnelsanchezrodriguez@gmail.com}{arnelsanchezrodriguez@gmail.com}\par
	\vspace{3mm} \par
	{\large Samuel Efraín Pupo Wong \space Grupo: C312 \par}
	\href{mailto:s.pupo@estudiantes.matcom.uh.cu}{s.pupo@estudiantes.matcom.uh.cu}
	\vspace{3mm} \par
	{\large Darián Ramón Mederos \space Grupo: C312 \par}
	\href{mailto:darianrm24@gmail.com}{darianrm24@gmail.com}
	\vspace{3mm} \par
	\vfill
	{\Large 2021-2022 \par}
\end{titlepage}	
\pagebreak
\tableofcontents
\pagebreak
\section{Motociclismo de Velocidad}
	El motociclismo de velocidad es una modalidad deportiva del motociclismo disputada en circuitos de carreras pavimentados. Las motocicletas que se usan pueden ser prototipos, es decir, desarrolladas específicamente para competición, o derivadas de modelos de serie (en general motocicletas deportivas), con modificaciones para aumentar las prestaciones. En el primer grupo entran las que participan en el Campeonato Mundial de Motociclismo, y en el segundo las \emph{Superbikes}, las \emph{Supersport} y las \emph{Superstock}.
	
	Estas deben presentar una serie de características como: estabilidad, alta velocidad (tanto en recta como en paso por curva), gran aceleración, gran frenada, fácil maniobrabilidad y bajo peso.
	
	\begin{center}
		\includegraphics[width = 12cm]{imagen1} 
	\end{center}	
	
\section{Estructura del Paddock}
	 En MotoGP, el \textbf{Jefe Técnico} de cada estructura se configura como una personalidad de bastante importancia dentro de un box, pues es quien se encarga de dirigir y controlar que todo funcione como un excelente engranaje que gane carreras. De igual importancia son los \textbf{Ingenieros Telemétricos}, pues son las personas que se encargan de analizar, leer y comprender todos los datos proporcionados por el piloto, así como transmitírselos al protagonista. Se trata de una figura de la que depende mucha de la información acerca de cualquier cambio realizado en la moto o asumir los puntos más fuertes de sus pilotos. Los \textbf{Mecánicos} también desempeñan un papel fundamental a la hora de construir la máquina perfecta.

\section{Pista}
	Se utilizará como referencia el circuito de Misano, Misano World Circuit Marco Simoncelli, autódromo localizado en la fracción de Santa Mónica, comuna de Misano Adriático (provincia de Rímini), región de Emilia-Romaña, Italia. 
	
	\begin{center}
		\includegraphics[width = 12cm]{circuito} 
	\end{center}

\section{Definición del Problema}
	Se tienen varios pilotos con sus respectivas motos, las cuáles difieren entre sí en cuanto a sus prestaciones. Cada uno posee su propio método de manejo, siendo algunos más cuidadosos y otros más agresivos. La pista se encuentra influenciada por el accionar del clima, puesto que no es lo mismo el manejo durante un día soleado que bajo la lluvia. Por tanto, el resultado de un piloto se verá condicionado por la combinación de su moto, su modo de conducción, la pista y el clima.\par
	Sin embargo, durante la carrera las condiciones pueden variar y es necesario realizar los ajustes necesarios para que el piloto mejore su rendimiento, los cuales se harán al pasar de una sección a otra de la pista o al finalizar cada vuelta. Esto podrá hacerse utilizando un lenguaje imperativo, mediante el uso de palabras claves, para que el piloto no necesite analizar situaciones complejas y pueda concentrarse en pilotar de la forma más eficiente posible.\par
	De esta manera, la simulación de la carrera será dinámica, puesto que entre las vueltas podrán existir variaciones provocadas por los ajustes propuestos por el Jefe Técnico, el cuál podrá ser una persona o una IA.\par


\newpage
			
\section{Simulación {\footnotesize \cite{conferenciasS}\cite{garcia}}}
	Se desea simular una carrera de MotoGP. Con tal fin, se utiliza una estructura agente conformada por un piloto y una moto, y una estructura ambiente formada por el clima y la pista. Se trata de un sistema multiagentes en el que dos de estos pueden interactuar entre sí, ya sea en modo ofensivo o en modo defensivo. Las variables de las distintas entidades se manipulan utilizando una escala del 1 al 10, donde sus valores se clasifican como: bajos (menores que 4), medios (entre 4 y 6), y altos (mayores que 6); excepto en los casos en los que se utilizan estructuras \emph{Enums} para definir los datos.
	
	\subsection{Ambiente}
		El ambiente es simulado utilizando variables aleatorias con distribución normal, que responden al estado del clima, la humedad, la temperatura, la visibilidad y la dirección e intensidad del viento. Del mismo modo, la pista contiene su nombre, la longitud que tiene una vuelta completa y una lista de secciones, donde cada sección está formada por el nombre, la longitud de esta, la velocidad máxima posible de alcanzar, hacia qué punto cardinal está orientada, el tipo de sección que es, si tiene un equivalente en boxes y en caso de tenerlo su longitud.
		
		Una función probabilística es la encargada de lanzar un evento de cambio de clima, generando nuevo estado de este. Además, cada vez que termina una vuelta de la carrera se varían los parámetros del ambiente.

		El circuito de Misano es el escogido por defecto para la competición. Sin embargo, es posible reestructurar la pista para crear una experiencia diferente o, incluso, generar una nueva pista de manera automática aleatoriamente. Mas debemos asegurarnos de que estas nuevas creaciones sean estructuras válidas.

		El método de reestructuración intercambia las curvas o rectas con otras secciones de su mismo tipo y su misma orientación cardinal. De este modo, se asegura de que la nueva estructura solo varíe el orden y no se pierdan las propiedades que la hacen cerrada.

		Por otro lado, generar una nueva pista de manera completamente aleatoria y automática es una problemática topológica de un mayor nivel de complejidad. Como solución factible se genera una línea poligonal que parte de un punto y se dirige en sentido opuesto variando su orientación. Dicha línea es abierta, pero su punto final está orientado cardinalmente en sentido inverso al punto inicial. Luego, tomando una copia exacta de esta y rotándola $180^0$, se puede crear una  figura poligonal cerrada con simetría central, la cual responde a las condiciones necesarias de una pista.

	\subsection{Agentes}
		Un agente está compuesto por: una moto, la cual posee la marca, el modelo, la velocidad máxima alcanzable, el peso, el tipo de neumáticos, los frenos, la rigidez del chasis, la probabilidad de romperse, y la probabilidad de que exploten los neumáticos por desgaste; además, por un piloto, conformado por el nombre, por la habilidad de pasar por la curva y por la recta, la probabilidad de caerse de la moto, la independencia, la agresividad y la pericia. 

		Los agentes parten con un ranking desde el inicio, asumiendo que este se alcanzó el día anterior en las clasificaciones. El inicio de la carrera se hace desde la primera sección de la pista, y tomando un piloto a la vez se calculan sus interacciones, haciendo que avance a la próxima sección. Para simular la carrera, se utiliza una cola con prioridad de manera que siempre se analice al piloto que menor tiempo tiene, lo cual permite darle el turno al más rápido primero, de modo que puede haber varios agentes en diferentes secciones. A la hora de pasar por meta, se muestra el ranking según van completando las vueltas, hasta que se completa la carrera.

		 Las acciones que el agente puede ejecutar en un instante determinado dependen de las variables del ambiente, las del propio agente, y las de sus rivales inmediatos hacia adelante y hacia atrás. Analizando las consecuencias de la acción escogida, se considera si fue correcta y sobrepasó la sección o no, en caso contrario. De efectuar ataque o defensa, se provoca una interacción con otros agentes. Si un ataque es satisfactorio, se intercambian las posiciones en el ranking; sino el tiempo de la carrera sufre una penalización. Existen variables probabilísticas que calculan si el piloto comete un error y debe abandonar la carrera o provoca un accidente que saque de la carrera a otro piloto, o a ambos.
	
	\subsection{Interacciones entre los parámetros}
		Los parámetros de las distintas entidades pueden interactuar entre ellos, lo que trae determinadas consecuencias, algunas positivas y otras negativas. Dado que dichas interacciones se producen en mayor o menor medida, luego de varias pruebas se obtuvo una escala que se puede considerar funcional, puesto que se acerca a los resultados de una carrera real. Para lograr un mejor realismo, se hace una primera variación de parámetros para adaptar a las entidades a las condiciones climatológicas del momento; luego, en cada cambio de vuelta se modifica el clima y se reajustan los parámetros de acuerdo las nuevas condiciones climatológicas.


\newpage

\section{Inteligencia Artificial  {\footnotesize \cite{conferenciasIA}\cite{russell}}}
	Como nuestro proyecto se basa en simular una carrera de MotoGP donde hay $n$ corredores, aquellos que no hayan sido diseñados mediante DSL son controlados por IA, el comportamiento de la cual varía a partir de las condiciones del ambiente que lo rodea, las características de su moto y la experiencia del propio piloto.
	
	Para la implementación de la IA se utilizan Sistemas Expertos generados mediante el uso de un procedimiento declarativo/imperativo, apoyándonos en la biblioteca PyKE\cite{pyke} de Python.
	
	Se emplea como base de conocimiento el conjunto de variables que forman parte de la simulación y que influyen en su desempeño, como:
	\begin{itemize}
		\item las características de la moto (velocidad, frenos, chasis)
		\item el estado del clima (soleado, nublado o lluvioso)
		\item la intensidad y el sentido del viento
		\item la humedad y la temperatura del ambiente
		\item la sección de pista que se está corriendo (curva o recta)
		\item la velocidad máxima alcanzable en la sección
		\item las habilidades del piloto (en rectas y curvas)
		\item entre otros
	\end{itemize}
	
	\subsection{Configuración de la moto}
	La primera heurística es la encargada de escoger la mejor configuración de la moto. De este modo, atendiendo a las condiciones iniciales de la carrera (que serán los hechos), la IA podrá tomar decisiones atendiendo a las reglas definidas. Al ser declarativas, las determinaciones tomadas se obtendrán mediante match hechos-reglas.
	Los hechos del sistema se presentan mediante una lógica difusa y son procesados para ser analizados:
	\begin{lstlisting}[language={PySharp}, label={Script}]
		rainy(True)
		humidity(False)
		windy(False)
		wind_direction(2)
	\end{lstlisting}
	
	Las reglas del sistema se formulan del modo:
	\begin{lstlisting}[language={PySharp}, label={Script}]
		soft
		use select_tires(0)
		when
		moto_facts.windy(True)
		moto_facts.wind_direction(3)
		
		medium_1
		use select_tires(1)
		when
		moto_facts.windy(False)
		
		medium_2
		use select_tires(1)
		when
		moto_facts.windy(True)
		moto_facts.wind_direction(2)
		
		hard
		use select_tires(2)
		when
		moto_facts.windy(True)
		moto_facts.wind_direction(1)
	\end{lstlisting}
	
	Luego, consultando los resultados obtenidos por las librerías de PyKE\cite{pyke}, mediante Python de manera imperativa será posible la interacción de la estructura antes expuesta con la simulación de la carrera.
	Atendiendo al ejemplo mostrado de selección de gomas, el sistema declarativo de PyKE\cite{pyke} devuelve el cálculo de una ecuación:
	$$valor\_tipo\_goma + valor\_goma = selección$$
	
	El resultado obtenido se utiliza para generar el tipo de las gomas seleccionadas, mediante el uso de un Enum en Python:
	\begin{lstlisting}[language={Python}, label={Script}]
		class Tires(Enum):
		Slick_Soft = 0
		Slick_Medium = 1
		Slick_Hard = 2
		Rain_Soft = 3
		Rain_Medium = 4
	\end{lstlisting}
	
	\subsection{Selección de acciones}
	Una segunda heurística será la encargada de escoger la acción que debe ejecutar el piloto, atendiendo a las condiciones de la carrera:
	\begin{itemize}
		\item aumentar/disminuir/mantener velocidad
		\item doblar
		\item ir a los pits
		\item combinaciones de todas las anteriores
	\end{itemize}
	(Ejemplo: aumentar velocidad + doblar + ir a los pits)
	
	En este caso, se utiliza el mismo método expuesto en la configuración de la moto: declarativo/imperativo con el uso de PyKE.
	Se analizan los parámetros de velocidad, sección de la pista y estado del clima:
	\begin{lstlisting}[language={PySharp}, label={Script}]
		speed(3)
		curve(False)
		tires(False)
		rainy(True)
		humidity(False)
	\end{lstlisting}
	
	Y se decide tomándolos en cuenta:
	\begin{lstlisting}[language={PySharp}, label={Script}]
		speed_up
		use select_action(0)
		when
		action_facts.speed(3)
		
		keep_speed
		use select_action(1)
		when
		action_facts.speed(2)
		
		brake
		use select_action(2)
		when
		action_facts.speed(1)
		
	\end{lstlisting}
	
	Asimismo, se calcula mediante una ecuación el valor de la decisión tomada:
	$acción\_velocidad + doblar + pits = acción$
	
	\begin{lstlisting}[language={Python}, label={Script}]
		class AgentActions(Enum):
		SpeedUp = 0
		KeepSpeed = 1
		Brake = 2
		SpeedUp_Turn = 3
		KeepSpeed_Turn = 4
		Brake_Turn = 5
		SpeedUp_Pits = 6
		KeepSpeed_Pits = 7
		Brake_Pits = 8
		SpeedUp_Turn_Pits = 9
		KeepSpeed_Turn_Pits = 10
		Brake_Turn_Pits = 11
	\end{lstlisting}
	
	\subsection{Selección de la aceleración}
	Una tercera heurística es la encargada de escoger la mejor aceleración en una sección dada de la pista, con el objetivo de alcanzar la mayor velocidad posible sin causar un accidente que obligue a abandonar la carrera. 
	Primeramente, se calcula la aceleración máxima alcanzable, tomando en cuenta que no se exceda la velocidad máxima admitida por la moto y la sección que se recorre.
	$a_{max}=(V_{max}^{2}-V^{2})/(2*X)$
	Luego, se establece un sistema de penalizaciones que disminuyen dicha aceleración si no se poseen las condiciones óptimas del ambiente (clima, humedad, temperatura) y del piloto (destreza en curvas y rectas).
	El resultado obtenido es incorporado a la simulación para continuar la carrera. De su valor depende mucho si el piloto obtiene un buen tiempo o sufre un accidente que lo saque de la competencia.


\newpage

\section{Definición del Lenguaje {\footnotesize \cite{conferenciasC}\cite{ullman}}}
	\subsection{Introducción a PySharp (P\#)}
	\subsubsection{Hello world!}
	
	\begin{lstlisting}[language={PySharp}]
		method int main() {
			return 0;
		}
	\end{lstlisting}	
	Los archivos de P\# suelen tener la extensión de archivo .pys.\par
	
	\subsubsection{Estructura del Programa}
	Los conceptos organizativos clave en P\# son programas, tipos y miembros. Los programas P\# constan de un archivo fuente. Los programas declaran tipos y miembros. Las motocicletas y los motociclistas son ejemplos de tipos. Los métodos y propiedades son ejemplos de miembros.
	
	\subsubsection{Tipos y Variables}
	En P\# solo existen tipos de valor, no hay de referencia. Por tanto, todas las variables contienen directamente sus datos, cada una tiene su propia copia y no es posible que las operaciones en una afecten a otra.\par
	\begin{center}
		\begin{tabular}{| c | c | m{5cm} | }
			\hline
			Categoría & Tipo & Descripción \\ \hline
			\multirow{5}{*}{Tipos} & \multirow{4}{*}{Tipos Simples} & Entero con signo: int \\ \cline{3-3}
			&  & Punto flotante IEEE: double \\ \cline{3-3}
			&  & Booleanos: bool \\ \cline{3-3}
			&  & Cadenas Unicode: string \\ \cline{2-3}
			& Tipos que aceptan valores NULL & Extensiones de todos los demás tipos de valor con un valor nulo \\ \hline
		\end{tabular}
	\end{center}
	\subsubsection{Expresiones}
	Las expresiones se construyen a partir de operandos y operadores. Los operadores de una expresión indican qué operaciones aplicar a los operandos. Los ejemplos de operadores incluyen +, -, * y /. Los ejemplos de operandos incluyen literales, variables y expresiones.\par
	\begin{center}
		\begin{tabular}{| c | c | m{5cm} | }
			\hline
			Categoría & Expresión & Descripción \\ \hline
			\multirow{2}{*}{Primaria} & x(...) & Invocación de método \\ \cline{2-3}		
			\multirow{4}{*}{Multiplicativa} & x * y & Multiplicación \\ \cline{2-3}
			& x / y & División \\ \cline{2-3}
			& x \% y & Resto \\ \cline{2-3} 
			& x ** y & Exponenciación \\ \hline
			\multirow{2}{*}{Aditiva} & x + y & Adición y concatenación de strings \\ \cline{2-3}
			& x - y & Substracción \\ \hline
			\multirow{4}{*}{Relacionales} & x < y & Menor que \\ \cline{2-3} 
			& x > y & Mayor que \\ \cline{2-3}
			& x <= y & Menor o igual que \\ \cline{2-3} 
			& x >= y & Mayor o igual que \\ \hline
			\multirow{2}{*}{Igualdad} & x == y & Igual \\ \cline{2-3} 
			& x != y & Distinto \\ \hline 
			Condicionales AND & x \&\& y & Evalúa y si y sólo si x es verdadera \\ \hline
			Condicionales OR & x || y & Evalúa y si y sólo si x es falsa \\ \hline
			Condicionales XOR & x \textasciicircum{} y & \\ \hline
			\multirow{2}{*}{Asignación} & x = y & Asignación \\ \cline{2-3}
			& x op= y & Asignación compuesta; los operadores admitidos son *= /= \%= **= += -= \&\&= ||= \textasciicircum{}= \\ \hline
		\end{tabular}
	\end{center}
	\subsubsection{Declaraciones}
	Las acciones de un programa se expresan mediante declaraciones. P\# admite varios tipos diferentes de declaraciones, algunas de las cuales se definen en términos de declaraciones integradas.
	
	Un \textbf{bloque} permite escribir múltiples declaraciones en contextos donde se permite una sola declaración. Un bloque consta de una lista de declaraciones escritas entre los delimitadores\{y\}.
	
	Las sentencias de \textbf{declaración} se utilizan para declarar variables, valga la redundancia.
	
	\begin{lstlisting}[language={PySharp}]
		method void example() {
			int a = 1;
		}
	\end{lstlisting}
	
	Las \textbf{declaraciones de expresión} se utilizan para evaluar expresiones. Las expresiones que se pueden usar como declaraciones incluyen invocaciones de métodos, asignaciones que usan = y los operadores de asignación compuesta.
	
	\begin{lstlisting}[language={PySharp}]
		method int example() {
			int a = 1;
			return a + 2;
		}
	\end{lstlisting}
	
	La \textbf{instrucción de selección} se utiliza para seleccionar una de varias declaraciones posibles para su ejecución en función del valor de alguna expresión. Este es el caso de la sentencia \textbf{if}.
	
	\begin{lstlisting}[language={PySharp}]
		method int example(int a) {
			if (a < 5) {
				return a;
			}
			else {
				return a % 5;
			}
		}
	\end{lstlisting}
	
	La \textbf{instrucción de iteración} se utiliza para ejecutar repetidamente una instrucción incorporada. Este es el caso de la instrucción \textbf{while}.
	
	\begin{lstlisting}[language={PySharp}]
		method int example(int a) {
			while (a > 5) {				
				a -= 1;
			}
			return a;
		}
	\end{lstlisting}
	
	Las \textbf{sentencias de salto} se utilizan para transferir el control. En este grupo están las declaraciones de \textbf{break}, \textbf{continue} y \textbf{return}.
	
	\begin{lstlisting}[language={PySharp}]
		method int example() {
			x = 10
			while (true) {				
				if (x < 100) {
					x += 10;
					continue;
				}
				else {
					break;
				}
			}
			return 0;
		}
	\end{lstlisting}
	
	\subsubsection{Tipos especiales}
	Los \textbf{tipos especiales} son los elementos más importantes de P\#, constituyen estructuras de bloques compuestas por acciones (métodos). Un tipo proporciona una definición para casos de, por ejemplo, motociclistas o motocicletas. Su declaración comienza con un encabezado que especifica qué tipo se va a crear y el nombre que se le dará a esta instancia. El encabezado va seguido del cuerpo del tipo, que consiste en una lista de declaraciones de miembros escritas entre los delimitadores\{y\}.
	
	\begin{lstlisting}[language={PySharp}]
		rider Rossi() {
			method int select_action() {    
				return 0;
			}
			method void select_acceleration(){
				...
			}
			...
		}
	\end{lstlisting}
	\subsubsection{Métodos}
	Un \textbf{método} es un miembro que implementa un cálculo o acción que se puede realizar por tipo. Los métodos tienen una lista de \textbf{parámetros}, que representan valores de variables pasadas al método, y un tipo de retorno, que especifica el tipo de valor calculado y devuelto por el método. El tipo de retorno de un método es nulo si no devuelve un valor.
	
	\subsubsection{Parámetros}
	Los \textbf{parámetros} se utilizan para pasar valores de variables a métodos. Los parámetros de un método obtienen sus valores reales de los \textbf{argumentos} que se especifican cuando se invoca el método. Las modificaciones de un valor de parámetro no afectan el argumento que se pasó para el parámetro.
	
	\subsubsection{Cuerpo del método y variables locales}
	El cuerpo de un método especifica las declaraciones que se ejecutarán cuando se invoca el método. El cuerpo de un método puede declarar variables que son específicas de la invocación del método. Estas variables se denominan variables locales. Una declaración de variable local especifica un nombre de tipo, un nombre de variable y un valor inicial.
	
	\subsubsection{Operadores}
	Un \textbf{operador} es un miembro que define el significado de aplicar un operador de expresión particular. Se pueden definir solamente operadores binarios.\par
	
	\textbf{Operadores Binarios:}
	\begin{lstlisting}[language={PySharp}]
		3+5;
		true && false;
	\end{lstlisting}
	
	\subsubsection{Análisis Léxico}
	\textbf{input}\par
	: input\_element* new\_line\par
	| directive\par
	;\par
	
	\textbf{input\_element}\par
	: whitespace\par
	| comment\par
	| token\par
	;\par
	
	\underline{\textbf{Terminadores de línea}}\par
	\textbf{new\_line}\par
	: '<Caracter de retorno (U+000D)>'\par
	| '<Caracter de avance de línea (U+000A)>'\par
	;\par
	
	\textbf{whitespace}\par
	: '<Cualquier personaje con clase Unicode Zs>'\par
	| '<Caracter de tabulación horizontal (U+0009)>'\par
	;\par
	
	\underline{\textbf{Comentarios}}\par
	\textbf{comment}\par
	: '\#' comment\_section '\#'\par
	;\par
	
	\underline{\textbf{Tokens}}\par
	\textbf{token}\par
	: identifier\par
	| keyword\par
	| literal\par
	| operator\_or\_punctuator\par
	;\par
	
	\underline{\textbf{Identificadores}}\par
	\textbf{identifier}\par
	: '<Un identificador que no es una palabra clave>'\par
	| identifier\_start\_character identifier\_part\_character*\par
	;\par
	
	\textbf{identifier\_start\_character}\par
	: letter\_character\par
	| '<Caracter guión bajo (U+005F)>'\par
	;\par
	
	\textbf{identifier\_part\_character}\par
	: letter\_character\par
	| decimal\_digit\par
	| '<Caracter guión bajo (U+005F)>'\par
	;\par
	
	\textbf{letter\_character}\par
	: uppercase\_letter\_character\par
	| lowercase\_letter\_character\par
	;\par
	
	\textbf{uppercase\_letter\_character}\par
	: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H'\par 
	| 'I' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q'\par 
	| 'R' | 'S' | 'T' | 'V' | 'X' | 'Y' | 'Z'\par    
	;\par
	
	\textbf{lowercase\_letter\_character}\par
	: 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h'\par 
	| 'i' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q'\par
	| 'r' | 's' | 't' | 'v' | 'x' | 'y' | 'z'\par
	;\par
	
	\textbf{decimal\_digit}\par
	: '0' | '1' | '2' | '3' | '4'\par 
	| '5' | '6' | '7' | '8' | '9'\par
	;\par
	
	\underline{\textbf{Palabras Claves}}\par
	\textbf{keyword}\par             
	: 'bool'\par
	| 'break'\par
	| 'continue'\par 
	| 'double'\par
	| 'elif'\par
	| 'else'\par
	| 'false'\par
	| 'if'\par
	| 'int'\par
	| 'method'\par
	| 'null'\par
	| 'return'\par
	| 'string'\par
	| 'true'\par
	| 'void'\par
	| 'while'\par
	
	| 'bike'\par
	| 'rider'\par
	
	| 'brakes'\par
	| 'max\_speed'\par
	| 'weight'\par
	| 'chassis\_stiffness'\par
	| 'speed'\par
	| 'tyres'\par
	| 'cornering'\par
	| 'step\_by\_line'\par		
	;\par
	
	\underline{\textbf{Literales}}\par
	\textbf{literal}\par
	: boolean\_literal\par
	| integer\_literal\par
	| double\_literal\par
	| string\_literal\par
	| null\_literal\par
	;\par
	
	\underline{\textbf{Literales Booleanos}}\par
	\textbf{boolean\_literal}\par
	: 'true'\par
	| 'false'\par
	;\par
	
	\underline{\textbf{Literales Enteros}}\par
	\textbf{integer\_literal}\par
	: decimal\_digit\par
	;\par
	
	\underline{\textbf{Literales flotantes}}\par
	\textbf{double\_literal}\par
	: decimal\_digit+ '.' decimal\_digit+\par
	;\par
	
	\underline{\textbf{Literales de Cadenas}}\par
	\textbf{string\_literal}\par
	: '\"' string\_literal\_character* '\"'\par
	;\par
	
	\textbf{string\_literal\_character}\par
	: '<Cualquier caracter, excepto " (U+0022)'\par
	;\par
	
	\underline{\textbf{Literales Nulos}}\par
	\textbf{null\_literal}\par
	: 'null'\par
	;\par
	
	\underline{\textbf{Operadores y signos de puntuación}}\par		
	\textbf{operator\_or\_punctuator}\par
	: '\{' \par
	| '\}' \par
	| '[' \par
	| ']' \par
	| '(' \par
	| ')' \par
	| '.' \par
	| ',' \par  
	| ':' \par
	| ';' \par
	| '+' \par
	| '-' \par
	| '*' \par
	| '/' \par
	| '\%' \par
	| '**' \par
	| '=' \par
	| '<' \par
	| '>' \par
	| '\&\&' \par
	| '||' \par
	| '==' \par
	| '!=' \par
	| '<=' \par
	| '>=' \par
	| '+=' \par
	| '-=' \par
	| '*=' \par
	| '/=' \par
	| '\%=' \par
	| '**=' \par
	| '\&\&=' \par
	| '||=' \par
	| '\textasciicircum{}=' \par
	;\par
	\underline{\textbf{Directivas}}\par
	\textbf{directive}\par
	: 'include' '<Nombre\_del\_archivo.pys>' ';'\par
	;\par
	
	\subsection{Explicación de la Implementación}
        Para crear nuestra gramática nos apoyamos en los lenguajes Python y CSharp, de ahi el nombre de nuestro DSL PSharp. Luego de tener los tokens resultantes del tokenizer, acordamos quée tendríamos como una línea e implementamos el metodo split\_lines , el cual
        recibe los tokens y los convierte en líneas, estas líneas son pasadas al parser.

        El parser que decidimos desarrolar fue el parser LL, lo primero que hicimos fueron las producciones, donde decidimos como serían correctas sintácticamente nuestras líneas.Las producciones generan todas las posibles cadenas válidas para nuestro lenguaje y no existen cadenas que son generadas por nuestra grámatica que no pertenezcan a nuestro lenguaje.De esta forma con una gramática válida empezamos al proceso de parsing. Nuestro parser necesitó un método "hacer\_first" primeramente para hacer los first de cada cadena posible de nuestra gramatica, luego llamamos un método auxiliar "calcular\_first\_restantes" el cual tiene la función de calcular los first de los no terminales que aún no lo tienen calculado .Nos hace falta guardar los first de los no terminales porque los necesitamos para hallar los follows en el método "hacer\_follow". Luego de invocar a "hacer\_follow" debemos invocar un método auxiliar "completar\_follows" el cual se encarga de satisfacer la regla de los follows que dice que el follow de la cabeza de la produccion es subconjunto del follow del ultimo no terminal, si el último no terminal puede ser el último elemento de la producción.

        Teniendo los first y los follows construimos la tabla LL(1) mediante el método "construir\_tabla\_LL". Al tener la tabla ya podemos comprobar que nuestra gramática no es ambigua, siempre existe solo una producción que aplicar. Luego creamos el método parsear al que hay que pasarle todas las líneas de nuestro código una por una , este realiza la comprobación sintáctica y en este mismo método vamos a ir creando nuestro AST para luego hacer el chequeo semántico. Para crear el AST utilizamos métodos como "CreaNododExpresion",  "CreaNodoCondicion", "CreaNododFuncion", "EligeTipoDdeclaracion", entre muchos otros declarados en la clase Parser. 

        Nuestro AST tiene un nodo por cada declaración que se puede realizar en el código. Tiene un nodo para una definición de función, una 
        definición de variables, redefinición de variables, If, WHile, Rider, Bike, Return. En cada uno de estos nodos si existe un ámbito como es el caso del nodo If, el While, los tipos rider, bike, environment y la definición de función cada uno de estos nodos tienen como atributo un tipo de nodo Program, el cual posee una lista de declaraciones y por lo tanto en él se pueden guardar la lista de declaraciones que se haga en el ámbito.

        Explicada la estructura del AST pasamos al chequeo semántico sobre este. Hacemos 3 recorridos sobre el AST, el primero para validar cada nodo.Un nodo es válido si todo lo que tiene guardado en sus atributos que es dependiente del contexto puede ser utilizado desde ese contexto y de la forma que se quiere. Decimos esto porque por ejemplo, las variables solo se pueden redefinir en el contexto en que fueron definidas. Decir que cada vez que creamos una función o un tipo creamos un contexto que responde a dicho nodo. Todo lo que se defina en dicho ámbito pertenece a su contexto específicamnete, no importa si se define dentro de un
        while o dentro de un If. En resumen los contextos en nuestro programa funcionan como en python con la particularidad de que no tenemos variables globales, si quieres redefinir una variable debes hacerlo en el contexto donde fue definida y solo se crea un nuevo contexto cuando se crea una función fuera de un tipo o cuando se crea un tipo. Destacar que las funciones definidas dentro de los tipos no crean un contexto específico para ellas, sino que su contexto es el mismo que el de el tipo, y no se le pueden pasar parámetros a las que pueden ser utilizadas luego en la simulación.

        Volviendo al AST, hacemos una segunda pasada, en esta pasada verificamos los tipos,en los nodos en que hay expresiones inducimos el tipo. Decir que una expresión para nosotros puede ser una expresión aritmética, un bool, o un string, podemos incluir variables y llamado a función en una expresión. La tercera pasada la hacemos para evaluar nuestros nodos. Si encontramos un nodo Def\_Fun no lo evaluamos, una definición de función se evalúa cuando se llama a la función.

        Cuando se crea un tipo se importan las variables que puede tener ese tipo en la simulación y las que podría utilizar. Estas variables están predefinidas, por lo tanto se pueden redefinir, pero una definición de otra variable con un nombre igual al de alguna de estas variables predefinidas arrojaría un error, ya que existe una variable en ese contexto con ese nombre dentro del tipo. Dentro de cada tipo se pueden definir las funciones que el jefe técnico decida pero hay algunas funciones con nombres claves como son la función "select\_configuration" en un tipo Bike , las funciones "select\_acceleration" y "select\_action" en un tipo rider y la función probability\_change\_weather en un tipo environment. El objetivo de select\_configuration es seleccionar el tipo de gomas dadas las características de la moto y por tanto modificar la variable "tires" del contexto del tipo, la cual utilizará el simulador, esta función debe ser void, "select\_action" debe retornar un valor entero y es la encargada de elegir que acción realizara el piloto. La función "select\_acceleration" debe ser void y su objetivo es actualizar la aceleración de un agente. Las variables dentro de los tipos se actualizan justo antes de que la simulación utilice las funciones claves, para eso cada tipo tiene un método refreshContext que es quien se encarga de actualizar las variabes. Las variables que se pueden utilizar dentro de un tipo Bike son los atributos de dicha moto y las características del clima, dentro del tipo Rider podemos utilizar las características del piloto, algunas características del agente como son speed, acceleration
        y time\_lap, los atributos del clima y de la sección en la que esta el piloto en ese momento.Dentro de un tipo environment podemos utilizar solo las variables propias del clima y la variable track que es de tipo string y se utiliza si dicho tipo environment es a partir del cual se crea el clima al principio de la simulación , la variable track sirve para crear la pista de diferentes formas.      


	\subsection{Conexión Simulación - Compilación}
		El resultado del DSL si se hacen los 3 recorridos del AST sin error, son 3 listas, la primera lista con todos los pilotos que fueron
        creados, la segunda con todas las motos y la tercera con diferentes ambientes .A partir de estas listas se crean los pilotos, las motos y el ambiente en la simulación, puede definirse un ambiente o no en el DSL. 
        Los pilotos que no fueron creados en el DSL ejecutan sus métodos normalmente. En el caso de un piloto que fue creado desde el DSL se ejecuta la función definida en el DSL ,antes de ejecutarla se actualiza el contexto de la función para que esta pueda apoyarse en la situación actual. Luego de la ejecución de la función dependiendo que función se ejecutó se importa a la simulación la variable que se quiere desde el contexto del método.
	
\pagebreak
\bibliographystyle{unsrt}
\bibliography{./_static/bib}
\end{document}

